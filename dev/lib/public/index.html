<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · Pathfinder.jl</title><meta name="title" content="Public · Pathfinder.jl"/><meta property="og:title" content="Public · Pathfinder.jl"/><meta property="twitter:title" content="Public · Pathfinder.jl"/><meta name="description" content="Documentation for Pathfinder.jl."/><meta property="og:description" content="Documentation for Pathfinder.jl."/><meta property="twitter:description" content="Documentation for Pathfinder.jl."/><meta property="og:url" content="https://mlcolab.github.io/Pathfinder.jl/lib/public/"/><meta property="twitter:url" content="https://mlcolab.github.io/Pathfinder.jl/lib/public/"/><link rel="canonical" href="https://mlcolab.github.io/Pathfinder.jl/lib/public/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Pathfinder.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Single-path-Pathfinder"><span>Single-path Pathfinder</span></a></li><li><a class="tocitem" href="#Multi-path-Pathfinder"><span>Multi-path Pathfinder</span></a></li><li><a class="tocitem" href="#Turing-integration"><span>Turing integration</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/quickstart/">Quickstart</a></li><li><a class="tocitem" href="../../examples/initializing-hmc/">Initializing HMC</a></li><li><a class="tocitem" href="../../examples/turing/">Turing usage</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mlcolab/Pathfinder.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mlcolab/Pathfinder.jl/blob/main/docs/src/lib/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>Pathfinder.jl</code>&#39;s public interface.</p><p>See the <a href="../internals/#Internals">Internals</a> section for documentation of internal functions.</p><p>Pathfinder can be run in two primary modes: single- and multi-path.</p><h2 id="Single-path-Pathfinder"><a class="docs-heading-anchor" href="#Single-path-Pathfinder">Single-path Pathfinder</a><a id="Single-path-Pathfinder-1"></a><a class="docs-heading-anchor-permalink" href="#Single-path-Pathfinder" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Pathfinder.pathfinder"><a class="docstring-binding" href="#Pathfinder.pathfinder"><code>Pathfinder.pathfinder</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pathfinder(fun; kwargs...)</code></pre><p>Find the best multivariate normal approximation encountered while maximizing a log density.</p><p>From an optimization trajectory, Pathfinder constructs a sequence of (multivariate normal) approximations to the distribution specified by a log density function. The approximation that maximizes the evidence lower bound (ELBO), or equivalently, minimizes the KL divergence between the approximation and the true distribution, is returned.</p><p>The covariance of the multivariate normal distribution is an inverse Hessian approximation constructed using at most the previous <code>history_length</code> steps.</p><p><strong>Arguments</strong></p><ul><li><code>fun</code>: An object representing the log-density of the target distribution. Supported   types include:<ul><li>a callable with the signature   <code>f(params::AbstractVector{&lt;:Real}) -&gt; log_density::Real</code>.</li><li>an object implementing the   <a href="https://www.tamaspapp.eu/LogDensityProblems.jl/stable/#log-density-api">LogDensityProblems interface</a>.</li><li><a href="https://docs.sciml.ai/Optimization/stable/API/optimization_function/#SciMLBase.OptimizationFunction"><code>SciMLBase.OptimizationFunction</code></a>: wraps the <em>negative</em> log density. It must   have the necessary features (e.g. a gradient or Hessian function) for the chosen   <code>optimizer</code>.</li><li><a href="https://docs.sciml.ai/Optimization/stable/API/optimization_problem/#SciMLBase.OptimizationProblem"><code>SciMLBase.OptimizationProblem</code></a>: an optimization problem containing a   function with the same properties as the above <code>OptimizationFunction</code>, as well as an   initial point. If provided, <code>init</code> and <code>dim</code> are ignored.</li></ul></li></ul><p><strong>Keywords</strong></p><ul><li><code>dim::Int</code>: dimension of the target distribution. Ignored if <code>init</code> provided.</li><li><code>init::AbstractVector{&lt;:Real}</code>: initial point of length <code>dim</code> from which to begin   optimization. If not provided and <code>fun</code> does not contain an initial point, an initial   point of type <code>Vector{Float64}</code> and length <code>dim</code> is created and filled using   <code>init_sampler</code>.</li><li><code>init_scale::Real</code>: scale factor <span>$s$</span> such that the default <code>init_sampler</code> samples   entries uniformly in the range <span>$[-s, s]$</span></li><li><code>init_sampler</code>: function with the signature <code>(rng, x) -&gt; x</code> that modifies a vector of   length <code>dims</code> in-place to generate an initial point</li><li><code>ndraws_elbo::Int=5</code>: Number of draws used to estimate the ELBO</li><li><code>ndraws::Int=ndraws_elbo</code>: number of approximate draws to return</li><li><code>rng::Random.AbstractRNG</code>: The random number generator to be used for drawing samples</li><li><code>executor::Transducers.Executor</code>: Transducers.jl executor that   determines if and how to perform ELBO computation in parallel. The default   (<a href="https://juliafolds2.github.io/Transducers.jl/stable/reference/manual/#Transducers.SequentialEx"><code>Transducers.SequentialEx()</code></a>) performs no   parallelization. If <code>rng</code> is known to be thread-safe, and the log-density function is   known to have no internal state, then   <a href="https://juliafolds2.github.io/Transducers.jl/stable/reference/manual/#Transducers.PreferParallel"><code>Transducers.PreferParallel()</code></a> may be used to   parallelize log-density evaluation. This is generally only faster for expensive log   density functions.</li><li><code>history_length::Int=6</code>: Size of the history used to approximate the   inverse Hessian.</li><li><code>optimizer</code>: Optimizer to be used for constructing trajectory. Can be any optimizer   compatible with <a href="https://docs.sciml.ai/Optimization/stable/">Optimization.jl</a>, so long   as it supports callbacks. Defaults to   <a href="https://julianlsolvers.github.io/Optim.jl/stable/algo/lbfgs/"><code>Optim.LBFGS</code></a><code>(; m=history_length, linesearch=LineSearches.HagerZhang(), alphaguess=LineSearches.InitialHagerZhang())</code>.</li><li><code>adtype::</code><a href="https://sciml.github.io/ADTypes.jl/stable/#ADTypes.AbstractADType"><code>ADTypes.AbstractADType</code></a>: Specifies which automatic   differentiation backend should be used to compute the gradient, if <code>fun</code> does not   already specify the gradient. Default is   <a href="https://sciml.github.io/ADTypes.jl/stable/#ADTypes.AutoForwardDiff"><code>ADTypes.AutoForwardDiff()</code></a> See   <a href="https://docs.sciml.ai/Optimization/stable/API/ad/#ad">Optimization.jl&#39;s Automatic Differentiation Recommendations</a>.</li><li><code>ntries::Int=1_000</code>: Number of times to try the optimization, restarting if it fails.   Before every restart, a new initial point is drawn using <code>init_sampler</code>.</li><li><code>fail_on_nonfinite::Bool=true</code>: If <code>true</code>, optimization fails if the log-density is a   <code>NaN</code> or <code>Inf</code> or if the gradient is ever non-finite. If <code>nretries &gt; 0</code>, then   optimization will be retried after reinitialization.</li><li><code>kwargs...</code> : Remaining keywords are forwarded to   <a href="https://docs.sciml.ai/Optimization/stable/API/solve/#CommonSolve.solve-Tuple%7BOptimizationProblem%2C%20Any%7D"><code>Optimization.solve</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><a href="#Pathfinder.PathfinderResult"><code>PathfinderResult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlcolab/Pathfinder.jl/blob/f0d832a501af610a0833d3136c52b4fec19a29a5/src/singlepath.jl#L85-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Pathfinder.PathfinderResult"><a class="docstring-binding" href="#Pathfinder.PathfinderResult"><code>Pathfinder.PathfinderResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PathfinderResult</code></pre><p>Container for results of single-path Pathfinder.</p><p><strong>Fields</strong></p><ul><li><code>input</code>: User-provided input object, e.g. a LogDensityProblem, <code>optim_fun</code>, <code>optim_prob</code>,   or another object.</li><li><code>optimizer</code>: Optimizer used for maximizing the log-density</li><li><code>rng</code>: Pseudorandom number generator that was used for sampling</li><li><code>optim_prob::</code><a href="https://docs.sciml.ai/Optimization/stable/API/optimization_problem/#SciMLBase.OptimizationProblem"><code>SciMLBase.OptimizationProblem</code></a>: Optimization problem used for   optimization</li><li><code>logp</code>: Log-density function</li><li><code>fit_distribution::</code><a href="https://juliastats.org/Distributions.jl/stable/multivariate/#Distributions.MvNormal"><code>Distributions.MvNormal</code></a>: ELBO-maximizing multivariate   normal distribution</li><li><code>draws::AbstractMatrix{&lt;:Real}</code>: draws from multivariate normal with size <code>(dim, ndraws)</code></li><li><code>fit_distribution_transformed</code>: <code>fit_distribution</code> transformed to the same space as the   user-supplied target distribution. This is only different from <code>fit_distribution</code> when   integrating with other packages, and its type depends on the type of <code>input</code>.</li><li><code>draws_transformed</code>: <code>draws</code> transformed to be draws from <code>fit_distribution_transformed</code>.</li><li><code>fit_iteration::Int</code>: Iteration at which ELBO estimate was maximized</li><li><code>num_tries::Int</code>: Number of tries until Pathfinder succeeded</li><li><code>optim_solution::</code><a href="https://docs.sciml.ai/Optimization/stable/API/optimization_solution/#SciMLBase.OptimizationSolution"><code>SciMLBase.OptimizationSolution</code></a>: Solution object of   optimization.</li><li><code>optim_trace::Pathfinder.OptimizationTrace</code>: container for optimization trace of points,   log-density, and gradient. The first point is the initial point.</li><li><code>fit_distributions::AbstractVector{Distributions.MvNormal}</code>: Multivariate normal   distributions for each point in <code>optim_trace</code>, where   <code>fit_distributions[fit_iteration + 1] == fit_distribution</code></li><li><code>elbo_estimates::AbstractVector{&lt;:Pathfinder.ELBOEstimate}</code>: ELBO estimates for all but   the first distribution in <code>fit_distributions</code>.</li><li><code>num_bfgs_updates_rejected::Int</code>: Number of times a BFGS update to the reconstructed   inverse Hessian was rejected to keep the inverse Hessian positive definite.</li></ul><p><strong>Returns</strong></p><ul><li><a href="#Pathfinder.PathfinderResult"><code>PathfinderResult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlcolab/Pathfinder.jl/blob/f0d832a501af610a0833d3136c52b4fec19a29a5/src/singlepath.jl#L16-L52">source</a></section></details></article><h2 id="Multi-path-Pathfinder"><a class="docs-heading-anchor" href="#Multi-path-Pathfinder">Multi-path Pathfinder</a><a id="Multi-path-Pathfinder-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-path-Pathfinder" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Pathfinder.multipathfinder"><a class="docstring-binding" href="#Pathfinder.multipathfinder"><code>Pathfinder.multipathfinder</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multipathfinder(fun, ndraws; kwargs...)</code></pre><p>Run <a href="#Pathfinder.pathfinder"><code>pathfinder</code></a> multiple times to fit a multivariate normal mixture model.</p><p>For <code>nruns=length(init)</code>, <code>nruns</code> parallel runs of pathfinder produce <code>nruns</code> multivariate normal approximations <span>$q_k = q(\phi | \mu_k, \Sigma_k)$</span> of the posterior. These are combined to a mixture model <span>$q$</span> with uniform weights.</p><p><span>$q$</span> is augmented with the component index to generate random samples, that is, elements <span>$(k, \phi)$</span> are drawn from the augmented mixture model</p><p class="math-container">\[\tilde{q}(\phi, k | \mu, \Sigma) = K^{-1} q(\phi | \mu_k, \Sigma_k),\]</p><p>where <span>$k$</span> is a component index, and <span>$K=$</span> <code>nruns</code>. These draws are then resampled with replacement. Discarding <span>$k$</span> from the samples would reproduce draws from <span>$q$</span>.</p><p>If <code>importance=true</code>, then Pareto smoothed importance resampling is used, so that the resulting draws better approximate draws from the target distribution <span>$p$</span> instead of <span>$q$</span>. This also prints a warning message if the importance weighted draws are unsuitable for approximating expectations with respect to <span>$p$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>fun</code>: An object representing the log-density of the target distribution. Supported   types include:</p><ul><li>a callable with the signature   <code>f(params::AbstractVector{&lt;:Real}) -&gt; log_density::Real</code>.</li><li>an object implementing the   <a href="https://www.tamaspapp.eu/LogDensityProblems.jl/stable/#log-density-api">LogDensityProblems interface</a>.</li><li><a href="https://docs.sciml.ai/Optimization/stable/API/optimization_function/#SciMLBase.OptimizationFunction"><code>SciMLBase.OptimizationFunction</code></a>: wraps the <em>negative</em> log density. It must   have the necessary features (e.g. a gradient or Hessian function) for the chosen   <code>optimizer</code>.</li><li><a href="https://docs.sciml.ai/Optimization/stable/API/optimization_problem/#SciMLBase.OptimizationProblem"><code>SciMLBase.OptimizationProblem</code></a>: an optimization problem containing a   function with the same properties as the above <code>OptimizationFunction</code>, as well as an   initial point. If provided, <code>init</code> and <code>dim</code> are ignored.</li></ul></li><li><p><code>ndraws::Int</code>: number of approximate draws to return</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>init</code>: iterator of length <code>nruns</code> of initial points of length <code>dim</code> from which each   single-path Pathfinder run will begin. <code>length(init)</code> must be implemented. If <code>init</code> is   not provided, <code>nruns</code> must be, and <code>dim</code> must be if <code>fun</code> provided.</li><li><code>nruns::Int</code>: number of runs of Pathfinder to perform. Ignored if <code>init</code> is provided.</li><li><code>ndraws_per_run::Int</code>: The number of draws to take for each component before resampling.   Defaults to a number such that <code>ndraws_per_run * nruns &gt; ndraws</code>.</li><li><code>importance::Bool=true</code>: Perform Pareto smoothed importance resampling of draws.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: Pseudorandom number generator. It is recommended to   use a parallelization-friendly PRNG like the default PRNG on Julia 1.7 and up.</li><li><code>executor::Transducers.Executor</code>: Transducers.jl executor that determines if and how to   run the single-path runs in parallel, defaulting to   <a href="https://juliafolds2.github.io/Transducers.jl/stable/reference/manual/#Transducers.SequentialEx"><code>Transducers.SequentialEx()</code></a>. If a transducer for   multi-threaded computation is selected, you must first verify that <code>rng</code> and the log   density function are thread-safe.</li><li><code>executor_per_run::Transducers.Executor</code>: Transducers.jl executor used within each run to   parallelize PRNG calls, defaulting to   <a href="https://juliafolds2.github.io/Transducers.jl/stable/reference/manual/#Transducers.SequentialEx"><code>Transducers.SequentialEx()</code></a>. See   <a href="#Pathfinder.pathfinder"><code>pathfinder</code></a> for further description.</li><li><code>kwargs...</code> : Remaining keywords are forwarded to <a href="#Pathfinder.pathfinder"><code>pathfinder</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><a href="#Pathfinder.MultiPathfinderResult"><code>MultiPathfinderResult</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlcolab/Pathfinder.jl/blob/f0d832a501af610a0833d3136c52b4fec19a29a5/src/multipath.jl#L68-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Pathfinder.MultiPathfinderResult"><a class="docstring-binding" href="#Pathfinder.MultiPathfinderResult"><code>Pathfinder.MultiPathfinderResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiPathfinderResult</code></pre><p>Container for results of multi-path Pathfinder.</p><p><strong>Fields</strong></p><ul><li><code>input</code>: User-provided input object, e.g. either <code>logp</code>, <code>(logp, ∇logp)</code>, <code>optim_fun</code>,   <code>optim_prob</code>, or another object.</li><li><code>optimizer</code>: Optimizer used for maximizing the log-density</li><li><code>rng</code>: Pseudorandom number generator that was used for sampling</li><li><code>optim_prob::</code><a href="https://docs.sciml.ai/Optimization/stable/API/optimization_problem/#SciMLBase.OptimizationProblem"><code>SciMLBase.OptimizationProblem</code></a>: Otimization problem used for   optimization</li><li><code>logp</code>: Log-density function</li><li><code>fit_distribution::</code><a href="https://juliastats.org/Distributions.jl/stable/mixture/#Distributions.MixtureModel"><code>Distributions.MixtureModel</code></a>: uniformly-weighted mixture of   ELBO-maximizing multivariate normal distributions from each run.</li><li><code>draws::AbstractMatrix{&lt;:Real}</code>: draws from <code>fit_distribution</code> with size <code>(dim, ndraws)</code>,   potentially resampled using importance resampling to be closer to the target   distribution.</li><li><code>draw_component_ids::Vector{Int}</code>: component id of each draw in <code>draws</code>.</li><li><code>fit_distribution_transformed</code>: <code>fit_distribution</code> transformed to the same space as the   user-supplied target distribution. This is only different from <code>fit_distribution</code> when   integrating with other packages, and its type depends on the type of <code>input</code>.</li><li><code>draws_transformed</code>: <code>draws</code> transformed to be draws from <code>fit_distribution_transformed</code>.</li><li><code>pathfinder_results::Vector{&lt;:</code><a href="#Pathfinder.PathfinderResult"><code>PathfinderResult</code></a><code>}</code>: results of each single-path   Pathfinder run.</li><li><code>psis_result::Union{Nothing,&lt;:</code><a href="https://julia.arviz.org/PSIS/stable/api/#PSIS.PSISResult"><code>PSIS.PSISResult</code></a><code>}</code>: If importance resampling   was used, the result of Pareto-smoothed importance resampling.   <code>psis_result.pareto_shape</code> also diagnoses whether <code>draws</code> can be used to compute   estimates from the target distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlcolab/Pathfinder.jl/blob/f0d832a501af610a0833d3136c52b4fec19a29a5/src/multipath.jl#L1-L30">source</a></section></details></article><h2 id="Turing-integration"><a class="docs-heading-anchor" href="#Turing-integration">Turing integration</a><a id="Turing-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Turing-integration" title="Permalink"></a></h2><p>The above functions have special overloads for supporting Turing models.</p><article><details class="docstring" open="true"><summary id="Pathfinder.pathfinder-Tuple{Model}"><a class="docstring-binding" href="#Pathfinder.pathfinder-Tuple{Model}"><code>Pathfinder.pathfinder</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pathfinder(model::DynamicPPL.Model; kwargs...) -&gt; PathfinderResult</code></pre><p>Run single-path Pathfinder on a Turing <code>model</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::</code><a href="https://turinglang.org/DynamicPPL.jl/stable/api/#DynamicPPL.Model-Tuple%7B%7D"><code>DynamicPPL.Model</code></a>: Turing/DynamicPPL model whose log-density will be   maximized.</li></ul><p><strong>Keywords</strong></p><ul><li><code>init::</code><a href="https://turinglang.org/DynamicPPL.jl/stable/api/#DynamicPPL.InitFromParams"><code>InitFromParams</code></a>: Initial model parameters.   If not provided, <code>init_sampler</code> is used.</li><li><code>init_sampler::</code><a href="https://turinglang.org/DynamicPPL.jl/stable/api/#DynamicPPL.AbstractInitStrategy"><code>AbstractInitStrategy</code></a>: A model   parameter initialization strategy. If not provided, a uniform sampler over the range   <code>[-init_scale, init_scale]</code> in unconstrained space is used.</li><li><code>init_scale::Real=2</code>: Scale of the default initial point sampler (in unconstrained space).</li><li>Remaining keywords are forwarded to the base method <a href="#Pathfinder.pathfinder"><code>pathfinder</code></a>.</li><li><code>chain_type::Type=MCMCChains.Chains</code>: The type of chain to return. Can be   <a href="https://turinglang.org/MCMCChains.jl/stable/chains/#MCMCChains.Chains-Tuple%7BChains%2C%20Union%7BAbstractString%2C%20Symbol%7D%7D"><code>MCMCChains.Chains</code></a>, <a href="https://pysm.dev/FlexiChains.jl/stable/api/#FlexiChains.FlexiChain-Union%7BTuple%7BAny%7D%2C%20Tuple%7BTKey%7D%7D%20where%20TKey"><code>FlexiChains.VNChain</code></a>,   or any other type for which a method <a href="https://turinglang.org/AbstractMCMC.jl/stable/api/#AbstractMCMC.from_samples"><code>AbstractMCMC.from_samples</code></a> converting   from a matrix of <a href="https://turinglang.org/DynamicPPL.jl/stable/api/#DynamicPPL.ParamsWithStats"><code>DynamicPPL.ParamsWithStats</code></a> is   defined.</li></ul><p><strong>Returns</strong></p><ul><li><a href="#Pathfinder.PathfinderResult"><code>PathfinderResult</code></a> where <code>draws_transformed</code> is an   <a href="https://turinglang.org/MCMCChains.jl/stable/chains/#MCMCChains.Chains-Tuple%7BChains%2C%20Union%7BAbstractString%2C%20Symbol%7D%7D"><code>MCMCChains.Chains</code></a> with constrained parameter values corresponding to the   unconstrained <code>draws</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Pathfinder, Turing, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function demo_model()
           α ~ Normal(0, 1)
           β ~ Beta(5, 1)
           σ ~ truncated(Normal(); lower=0)
       end;

julia&gt; init = InitFromParams((; α=0.0));

julia&gt; init_sampler = InitFromPrior();

julia&gt; result = pathfinder(demo_model(); rng, init, init_sampler);

julia&gt; result.draws_transformed
Chains MCMC chain (5×6×1 Array{Float64, 3}):

Iterations        = 1:1:5
Number of chains  = 1
Samples per chain = 5
parameters        = α, β, σ
internals         = logprior, loglikelihood, logjoint

Use `describe(chains)` for summary statistics and quantiles.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlcolab/Pathfinder.jl/blob/f0d832a501af610a0833d3136c52b4fec19a29a5/ext/PathfinderTuringExt.jl#L124-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Pathfinder.multipathfinder-Tuple{Model, Int64}"><a class="docstring-binding" href="#Pathfinder.multipathfinder-Tuple{Model, Int64}"><code>Pathfinder.multipathfinder</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">multipathfinder(model::DynamicPPL.Model, ndraws::Int; kwargs...) -&gt; MultiPathfinderResult</code></pre><p>Run multi-path Pathfinder on a Turing <code>model</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::</code><a href="https://turinglang.org/DynamicPPL.jl/stable/api/#DynamicPPL.Model-Tuple%7B%7D"><code>DynamicPPL.Model</code></a>: Turing/DynamicPPL model whose log-density will be   maximized.</li><li><code>ndraws::Int</code>: Number of draws to return after (optional) importance resampling.</li></ul><p><strong>Keywords</strong></p><ul><li><code>init</code>: A length <code>nruns</code> vector of <a href="https://turinglang.org/DynamicPPL.jl/stable/api/#DynamicPPL.InitFromParams"><code>InitFromParams</code></a>   containing initial model parameters. If not provided, <code>nruns</code> is required and   <code>init_sampler</code> is used.</li><li><code>nruns::Int</code>: Number of runs of Pathfinder to perform. Ignored if <code>init</code> is provided.</li><li>Remaining keywords are forwarded to the base method   <a href="#Pathfinder.multipathfinder"><code>multipathfinder</code></a> and   <a href="#Pathfinder.pathfinder-Tuple{Model}"><code>pathfinder(model; kwargs...)</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><a href="#Pathfinder.MultiPathfinderResult"><code>MultiPathfinderResult</code></a> where <code>draws_transformed</code>   (and each single-path result&#39;s <code>draws_transformed</code>) is an   <a href="https://turinglang.org/MCMCChains.jl/stable/chains/#MCMCChains.Chains-Tuple%7BChains%2C%20Union%7BAbstractString%2C%20Symbol%7D%7D"><code>MCMCChains.Chains</code></a> with constrained parameter values corresponding to the   unconstrained <code>draws</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Pathfinder, Turing, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function demo_model()
           α ~ Normal(0, 1)
           β ~ Beta(5, 1)
           σ ~ truncated(Normal(); lower=0)
       end;

julia&gt; init = [InitFromParams((; α)) for α in -4.0:4.0];

julia&gt; result = multipathfinder(
           demo_model(), 1_000; rng, init, init_sampler=InitFromPrior(),
       );

julia&gt; result.draws_transformed
Chains MCMC chain (1000×6×1 Array{Float64, 3}):

Iterations        = 1:1:1000
Number of chains  = 1
Samples per chain = 1000
parameters        = α, β, σ
internals         = logprior, loglikelihood, logjoint

Use `describe(chains)` for summary statistics and quantiles.
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mlcolab/Pathfinder.jl/blob/f0d832a501af610a0833d3136c52b4fec19a29a5/ext/PathfinderTuringExt.jl#L208-L264">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 12 February 2026 10:47">Thursday 12 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
