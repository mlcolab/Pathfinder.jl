<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Turing usage · Pathfinder.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://sethaxen.github.io/Pathfinder.jl/examples/turing/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Pathfinder.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../initializing-hmc/">Initializing HMC</a></li><li class="is-active"><a class="tocitem" href>Turing usage</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Turing usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Turing usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sethaxen/Pathfinder.jl/blob/master/docs/src/examples/turing.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Running-Pathfinder-on-Turing.jl-models"><a class="docs-heading-anchor" href="#Running-Pathfinder-on-Turing.jl-models">Running Pathfinder on Turing.jl models</a><a id="Running-Pathfinder-on-Turing.jl-models-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Pathfinder-on-Turing.jl-models" title="Permalink"></a></h1><p>This tutorial demonstrates how <a href="https://turing.ml/stable/">Turing</a> can be used with Pathfinder.</p><p>We&#39;ll demonstrate with a regression example.</p><pre><code class="language-julia hljs">using AdvancedHMC, LinearAlgebra, Pathfinder, Random, Turing
Random.seed!(39)

@model function regress(x, y)
    α ~ Normal()
    β ~ Normal()
    σ ~ truncated(Normal(); lower=0)
    y .~ Normal.(α .+ β .* x, σ)
end
x = 0:0.1:10
y = @. 2x + 1.5 + randn() * 0.2</code></pre><pre><code class="language-julia hljs">model = regress(collect(x), y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}(Main.regress, (x = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], y = [1.6664116869390373, 1.891497101913886, 1.7384305108256857, 2.2187296181842964, 2.3732885334405034, 2.769366183240351, 2.6402850816920136, 2.8316802176647675, 2.6147284441437417, 3.001320964172886  …  19.676131789844952, 20.12746375915987, 20.081681871812364, 20.2537624581252, 20.430828353298363, 20.75518547480482, 20.85047170077969, 21.424483267847467, 21.63606510912814, 21.12808223508428]), NamedTuple(), DynamicPPL.DefaultContext())</code></pre><p>The first way we can use Turing with Pathfinder is via its mode estimation functionality. We can use <code>Turing.optim_function</code> to generate a <code>SciMLBase.OptimizationFunction</code>, which <a href="../../lib/public/#Pathfinder.pathfinder"><code>pathfinder</code></a> and <a href="../../lib/public/#Pathfinder.multipathfinder"><code>multipathfinder</code></a> can take as inputs.</p><pre><code class="language-julia hljs">fun = optim_function(model, MAP(); constrained=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(func = SciMLBase.OptimizationFunction{true, SciMLBase.NoAD, Turing.ModeEstimation.var&quot;#l#5&quot;{Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}}, Turing.ModeEstimation.var&quot;#3#6&quot;{Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}}, Turing.ModeEstimation.var&quot;#4#7&quot;{Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}}, Nothing, Nothing, Nothing, Nothing}(Turing.ModeEstimation.var&quot;#l#5&quot;{Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}}(Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}(DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}(Main.regress, (x = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], y = [1.6664116869390373, 1.891497101913886, 1.7384305108256857, 2.2187296181842964, 2.3732885334405034, 2.769366183240351, 2.6402850816920136, 2.8316802176647675, 2.6147284441437417, 3.001320964172886  …  19.676131789844952, 20.12746375915987, 20.081681871812364, 20.2537624581252, 20.430828353298363, 20.75518547480482, 20.85047170077969, 21.424483267847467, 21.63606510912814, 21.12808223508428]), NamedTuple(), DynamicPPL.DefaultContext()), Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}(DynamicPPL.DefaultContext()), DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}((α = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(α =&gt; 1), [α], UnitRange{Int64}[1:1], [-0.306337066942797], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), β = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(β =&gt; 1), [β], UnitRange{Int64}[1:1], [1.4263375219406673], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), σ = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(σ =&gt; 1), [σ], UnitRange{Int64}[1:1], [-0.1589308206098669], Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}[Truncated(Distributions.Normal{Float64}(μ=0.0, σ=1.0); lower=0.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1]))), Base.RefValue{Float64}(-1802.153493097064), Base.RefValue{Int64}(1)))), SciMLBase.NoAD(), Turing.ModeEstimation.var&quot;#3#6&quot;{Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}}(Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}(DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}(Main.regress, (x = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], y = [1.6664116869390373, 1.891497101913886, 1.7384305108256857, 2.2187296181842964, 2.3732885334405034, 2.769366183240351, 2.6402850816920136, 2.8316802176647675, 2.6147284441437417, 3.001320964172886  …  19.676131789844952, 20.12746375915987, 20.081681871812364, 20.2537624581252, 20.430828353298363, 20.75518547480482, 20.85047170077969, 21.424483267847467, 21.63606510912814, 21.12808223508428]), NamedTuple(), DynamicPPL.DefaultContext()), Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}(DynamicPPL.DefaultContext()), DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}((α = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(α =&gt; 1), [α], UnitRange{Int64}[1:1], [-0.306337066942797], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), β = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(β =&gt; 1), [β], UnitRange{Int64}[1:1], [1.4263375219406673], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), σ = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(σ =&gt; 1), [σ], UnitRange{Int64}[1:1], [-0.1589308206098669], Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}[Truncated(Distributions.Normal{Float64}(μ=0.0, σ=1.0); lower=0.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1]))), Base.RefValue{Float64}(-1802.153493097064), Base.RefValue{Int64}(1)))), Turing.ModeEstimation.var&quot;#4#7&quot;{Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}}(Turing.ModeEstimation.OptimLogDensity{DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}, Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}, DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}}(DynamicPPL.Model{typeof(Main.regress), (:x, :y), (), (), Tuple{Vector{Float64}, Vector{Float64}}, Tuple{}, DynamicPPL.DefaultContext}(Main.regress, (x = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9  …  9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 10.0], y = [1.6664116869390373, 1.891497101913886, 1.7384305108256857, 2.2187296181842964, 2.3732885334405034, 2.769366183240351, 2.6402850816920136, 2.8316802176647675, 2.6147284441437417, 3.001320964172886  …  19.676131789844952, 20.12746375915987, 20.081681871812364, 20.2537624581252, 20.430828353298363, 20.75518547480482, 20.85047170077969, 21.424483267847467, 21.63606510912814, 21.12808223508428]), NamedTuple(), DynamicPPL.DefaultContext()), Turing.ModeEstimation.OptimizationContext{DynamicPPL.DefaultContext}(DynamicPPL.DefaultContext()), DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}((α = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(α =&gt; 1), [α], UnitRange{Int64}[1:1], [-0.306337066942797], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), β = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(β =&gt; 1), [β], UnitRange{Int64}[1:1], [1.4263375219406673], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), σ = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(σ =&gt; 1), [σ], UnitRange{Int64}[1:1], [-0.1589308206098669], Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}[Truncated(Distributions.Normal{Float64}(μ=0.0, σ=1.0); lower=0.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1]))), Base.RefValue{Float64}(-1802.153493097064), Base.RefValue{Int64}(1)))), nothing, nothing, nothing, nothing), init = Turing.ModeEstimation.Init{DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}, Turing.ModeEstimation.constrained_space{false}}(DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}((α = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(α =&gt; 1), [α], UnitRange{Int64}[1:1], [-0.306337066942797], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), β = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(β =&gt; 1), [β], UnitRange{Int64}[1:1], [1.4263375219406673], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), σ = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(σ =&gt; 1), [σ], UnitRange{Int64}[1:1], [-0.1589308206098669], Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}[Truncated(Distributions.Normal{Float64}(μ=0.0, σ=1.0); lower=0.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1]))), Base.RefValue{Float64}(-1802.153493097064), Base.RefValue{Int64}(1)), Turing.ModeEstimation.constrained_space{false}()), transform = Turing.ModeEstimation.ParameterTransform{DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}, Turing.ModeEstimation.constrained_space{true}}(DynamicPPL.TypedVarInfo{NamedTuple{(:α, :β, :σ), Tuple{DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}, DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}}}, Float64}((α = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:α, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:α, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(α =&gt; 1), [α], UnitRange{Int64}[1:1], [-0.306337066942797], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), β = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:β, Setfield.IdentityLens}, Int64}, Vector{Distributions.Normal{Float64}}, Vector{AbstractPPL.VarName{:β, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(β =&gt; 1), [β], UnitRange{Int64}[1:1], [1.4263375219406673], Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=0.0, σ=1.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1])), σ = DynamicPPL.Metadata{Dict{AbstractPPL.VarName{:σ, Setfield.IdentityLens}, Int64}, Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}}, Vector{AbstractPPL.VarName{:σ, Setfield.IdentityLens}}, Vector{Float64}, Vector{Set{DynamicPPL.Selector}}}(Dict(σ =&gt; 1), [σ], UnitRange{Int64}[1:1], [-0.1589308206098669], Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64}[Truncated(Distributions.Normal{Float64}(μ=0.0, σ=1.0); lower=0.0)], Set{DynamicPPL.Selector}[Set()], [0], Dict{String, BitVector}(&quot;del&quot; =&gt; [0], &quot;trans&quot; =&gt; [1]))), Base.RefValue{Float64}(-1802.153493097064), Base.RefValue{Int64}(1)), Turing.ModeEstimation.constrained_space{true}()))</code></pre><pre><code class="language-julia hljs">dim = length(fun.init())
pathfinder(fun.func; dim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Single-path Pathfinder result
  tries: 9
  draws: 5
  fit iteration: 17 (total: 21)
  fit ELBO: -0.2 ± 0.24
  fit distribution: Distributions.MvNormal{Float64, Pathfinder.WoodburyPDMat{Float64, LinearAlgebra.Diagonal{Float64, Vector{Float64}}, Matrix{Float64}, Matrix{Float64}, LinearAlgebra.Diagonal{Float64, Vector{Float64}}, LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}}, LinearAlgebra.UpperTriangular{Float64, Matrix{Float64}}}, Vector{Float64}}(
dim: 3
μ: [1.4756791589636236, 2.0060480974694594, -1.5519095930330966]
Σ: [0.001763074266651822 -0.00025292501945253554 -0.0001797379945779572; -0.00025292501945253554 5.069345304521976e-5 1.8086024595530317e-5; -0.0001797379945779572 1.8086024595530317e-5 0.0048990292501730134]
)
</code></pre><pre><code class="language-julia hljs">multipathfinder(fun.func, 1_000; dim, nruns=8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Multi-path Pathfinder result
  runs: 8
  draws: 1000
  Pareto shape diagnostic: 0.82 (bad)</code></pre><p>However, for convenience, <code>pathfinder</code> and <code>multipathfinder</code> can take Turing models as inputs and produce <code>MCMCChains.Chains</code> objects as outputs.</p><pre><code class="language-julia hljs">result_single = pathfinder(model; ndraws=1_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Single-path Pathfinder result
  tries: 17
  draws: 1000
  fit iteration: 16 (total: 18)
  fit ELBO: -0.36 ± 0.09
  fit distribution: Distributions.MvNormal{Float64, Pathfinder.WoodburyPDMat{Float64, LinearAlgebra.Diagonal{Float64, Vector{Float64}}, Matrix{Float64}, Matrix{Float64}, LinearAlgebra.Diagonal{Float64, Vector{Float64}}, LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}}, LinearAlgebra.UpperTriangular{Float64, Matrix{Float64}}}, Vector{Float64}}(
dim: 3
μ: [1.4756791549658692, 2.0060480975713424, -1.5519095892969128]
Σ: [0.0017481224180942237 -0.00026090604757332916 -2.1478535413406946e-5; -0.00026090604757332916 5.2195675001960235e-5 2.675995523435281e-6; -2.1478535413406946e-5 2.675995523435281e-6 0.0048567826645242946]
)
</code></pre><pre><code class="language-julia hljs">result_multi = multipathfinder(model, 1_000; nruns=8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Multi-path Pathfinder result
  runs: 8
  draws: 1000
  Pareto shape diagnostic: -0.32 (good)</code></pre><p>Here, the Pareto shape diagnostic indicates that it is likely safe to use these draws to compute posterior estimates.</p><p>When passed a <code>Model</code>, Pathfinder also gives access to the posterior draws in a familiar <code>MCMCChains.Chains</code> object.</p><pre><code class="language-julia hljs">result_multi.draws_transformed</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (1000×3×1 Array{Float64, 3}):

Iterations        = 1:1:1000
Number of chains  = 1
Samples per chain = 1000
parameters        = α, β, σ

Summary Statistics
  parameters      mean       std   naive_se      mcse         ess      rhat
      Symbol   Float64   Float64    Float64   Float64     Float64   Float64

           α    1.4791    0.0413     0.0013    0.0013   1048.1136    0.9990
           β    2.0055    0.0068     0.0002    0.0002    968.5792    0.9993
           σ    0.2161    0.0147     0.0005    0.0006    853.6517    1.0003

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
      Symbol   Float64   Float64   Float64   Float64   Float64

           α    1.3912    1.4522    1.4810    1.5057    1.5593
           β    1.9914    2.0012    2.0050    2.0101    2.0193
           σ    0.1898    0.2055    0.2159    0.2262    0.2455
</code></pre><p>We can also use these posterior draws to initialize MCMC sampling.</p><pre><code class="language-julia hljs">init_params = collect.(eachrow(result_multi.draws_transformed.value[1:4, :, 1]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{Float64}}:
 [1.506821516325871, 2.0064943067348686, 0.24549165028810724]
 [1.4091447460198858, 2.017273512466308, 0.23647240454518484]
 [1.5092068100404847, 1.9998168642315648, 0.20151020655740656]
 [1.5212845498226433, 1.9998487505319746, 0.19908102809267894]</code></pre><pre><code class="language-julia hljs">chns = sample(model, Turing.NUTS(), MCMCThreads(), 1_000, 4; init_params, progress=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (1000×15×4 Array{Float64, 3}):

Iterations        = 501:1:1500
Number of chains  = 4
Samples per chain = 1000
Wall duration     = 8.04 seconds
Compute duration  = 6.06 seconds
parameters        = α, β, σ
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters      mean       std   naive_se      mcse         ess      rhat    ⋯
      Symbol   Float64   Float64    Float64   Float64     Float64   Float64    ⋯

           α    1.4763    0.0422     0.0007    0.0010   1962.4830    1.0030    ⋯
           β    2.0059    0.0073     0.0001    0.0002   1848.5323    1.0034    ⋯
           σ    0.2166    0.0157     0.0002    0.0003   2234.6524    1.0002    ⋯
                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
      Symbol   Float64   Float64   Float64   Float64   Float64

           α    1.3899    1.4488    1.4764    1.5041    1.5561
           β    1.9919    2.0010    2.0060    2.0106    2.0205
           σ    0.1884    0.2056    0.2159    0.2266    0.2487
</code></pre><p>To use Pathfinder&#39;s estimate of the metric and skip warm-up, at the moment one needs to use AdvancedHMC directly.</p><pre><code class="language-julia hljs">ℓπ(x) = -fun.func.f(x, nothing)
function ∂ℓπ∂θ(x)
    g = similar(x)
    fun.func.grad(g, x, nothing)
    rmul!(g, -1)
    return ℓπ(x), g
end

ndraws = 1_000
nadapts = 50
inv_metric = result_multi.pathfinder_results[1].fit_distribution.Σ
metric = Pathfinder.RankUpdateEuclideanMetric(inv_metric)
hamiltonian = Hamiltonian(metric, ℓπ, ∂ℓπ∂θ)
ϵ = find_good_stepsize(hamiltonian, init_params[1])
integrator = Leapfrog(ϵ)
proposal = AdvancedHMC.NUTS{MultinomialTS,GeneralisedNoUTurn}(integrator)
adaptor = StepSizeAdaptor(0.8, integrator)
samples, stats = sample(
    hamiltonian,
    proposal,
    init_params[1],
    ndraws + nadapts,
    adaptor,
    nadapts;
    drop_warmup=true,
    progress=false,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([[1.4602036110601206, 2.0011977592648553, -1.4322104483679556], [1.5371000135647037, 1.9895299643352105, -1.5146468665027975], [1.563762813625645, 1.9951856511435793, -1.5313172089226827], [1.5402265216688569, 2.001344205564612, -1.5427540359272116], [1.4904059158541074, 2.006020334592259, -1.511930999465797], [1.506687638839148, 1.9984021076473715, -1.5101437546829097], [1.486645271318215, 2.0056304494642774, -1.5968187464102501], [1.4942952666527063, 2.0045451870697644, -1.5917376386931807], [1.506170166601471, 2.002443969707124, -1.602811970615049], [1.493520985958121, 2.001589314162776, -1.6150254490612639]  …  [1.4798438472819733, 2.00080638066043, -1.3898054278632763], [1.4749317523755514, 2.00798124316616, -1.6676013277658661], [1.5011366587058936, 1.9992550112160745, -1.566979501440091], [1.5168317148296024, 2.0036675531090866, -1.5636489397811655], [1.5085590159496416, 2.002037428203805, -1.5619102492347972], [1.4832499102260963, 2.006213311781574, -1.6434749993657087], [1.4699302367805025, 2.011003253311525, -1.6385218853543368], [1.4903634386564146, 2.004798359546178, -1.611915297275829], [1.4090033810158669, 2.0174401751494555, -1.5886883707600843], [1.4071430537929126, 2.015038924273629, -1.626954484220342]], NamedTuple[(n_steps = 31, is_accept = true, acceptance_rate = 0.6789621058065041, log_density = 5.312884442739618, hamiltonian_energy = -4.534857212138208, hamiltonian_energy_error = 0.592827581992684, max_hamiltonian_energy_error = 0.7832679817226618, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.9187697761897816, log_density = 5.187058726277832, hamiltonian_energy = -1.8354474060695516, hamiltonian_energy_error = 0.05477199505293884, max_hamiltonian_energy_error = -0.7147200182853344, tree_depth = 4, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 45, is_accept = true, acceptance_rate = 0.9921492789288894, log_density = 5.8553412379379495, hamiltonian_energy = -4.433175979316223, hamiltonian_energy_error = -0.6449388083361285, max_hamiltonian_energy_error = -0.7487197556618499, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 29, is_accept = true, acceptance_rate = 0.8821367620030728, log_density = 6.140916074406833, hamiltonian_energy = -4.5022143461995086, hamiltonian_energy_error = 0.27856028004622413, max_hamiltonian_energy_error = 0.3172969657392146, tree_depth = 4, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 27, is_accept = true, acceptance_rate = 0.9013474666359831, log_density = 7.840399860376391, hamiltonian_energy = -5.307504819856387, hamiltonian_energy_error = -0.2669404607211323, max_hamiltonian_energy_error = 0.3788044184454815, tree_depth = 4, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.9672186250412117, log_density = 7.477773242992325, hamiltonian_energy = -7.251066446109934, hamiltonian_energy_error = 0.053530638369683636, max_hamiltonian_energy_error = 0.0959938506538709, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 39, is_accept = true, acceptance_rate = 0.9896310691363911, log_density = 7.913012968377091, hamiltonian_energy = -6.885725596611761, hamiltonian_energy_error = -0.11686526648392892, max_hamiltonian_energy_error = -0.1544587007260665, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.9993012425447624, log_density = 7.884178509209884, hamiltonian_energy = -7.665367637955216, hamiltonian_energy_error = 0.0028396022045056313, max_hamiltonian_energy_error = -0.027640273991806907, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 15, is_accept = true, acceptance_rate = 0.9992269522221637, log_density = 7.621829156376851, hamiltonian_energy = -7.347481663875034, hamiltonian_energy_error = -0.012248216932777112, max_hamiltonian_energy_error = -0.030024728561003577, tree_depth = 3, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 63, is_accept = true, acceptance_rate = 0.8086938860827908, log_density = 7.561543125447835, hamiltonian_energy = -5.290427682621521, hamiltonian_energy_error = 0.03336021632001973, max_hamiltonian_energy_error = 0.42880935208197357, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false)  …  (n_steps = 23, is_accept = true, acceptance_rate = 0.8828266173999881, log_density = 5.244927461749969, hamiltonian_energy = -4.7465839623605985, hamiltonian_energy_error = 0.17829778314592648, max_hamiltonian_energy_error = 0.2701492391293918, tree_depth = 4, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 63, is_accept = true, acceptance_rate = 0.9862217540709212, log_density = 6.599833984379889, hamiltonian_energy = -3.439295024876594, hamiltonian_energy_error = -0.28986338771421005, max_hamiltonian_energy_error = -0.28986338771421005, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.9599170787237006, log_density = 7.658962038982871, hamiltonian_energy = -6.011945962837691, hamiltonian_energy_error = 0.0999200675023495, max_hamiltonian_energy_error = 0.11137104864609171, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.8673639058765912, log_density = 7.165935155861395, hamiltonian_energy = -6.757681182330719, hamiltonian_energy_error = 0.09379392767387973, max_hamiltonian_energy_error = 0.3755777793304578, tree_depth = 4, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 3, is_accept = true, acceptance_rate = 0.36699130586314704, log_density = 7.8648565946060565, hamiltonian_energy = -2.750197264476216, hamiltonian_energy_error = -0.21001258715475846, max_hamiltonian_energy_error = 3.0656185156724844, tree_depth = 2, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.992773932203436, log_density = 7.22557670341501, hamiltonian_energy = -5.479768356705103, hamiltonian_energy_error = 0.01826091525090945, max_hamiltonian_energy_error = 0.022432843774253364, tree_depth = 4, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 15, is_accept = true, acceptance_rate = 0.853777293752721, log_density = 6.653093622991201, hamiltonian_energy = -6.443645738455163, hamiltonian_energy_error = 0.32953523850290356, max_hamiltonian_energy_error = 0.33144559140488816, tree_depth = 4, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 63, is_accept = true, acceptance_rate = 0.9971379391935971, log_density = 7.7368199257618215, hamiltonian_energy = -6.847743392221423, hamiltonian_energy_error = -0.32575967532087, max_hamiltonian_energy_error = -0.353615373239621, tree_depth = 6, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.8303651327100378, log_density = 6.6219893333175825, hamiltonian_energy = -5.461670205134645, hamiltonian_energy_error = 0.03853260532712177, max_hamiltonian_energy_error = 0.3878204360872912, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false), (n_steps = 31, is_accept = true, acceptance_rate = 0.8866528065604966, log_density = 5.98037694504689, hamiltonian_energy = -5.045685410785726, hamiltonian_energy_error = -0.018281171163806675, max_hamiltonian_energy_error = 0.2785470330580502, tree_depth = 5, numerical_error = false, step_size = 0.0046017677486242985, nom_step_size = 0.0046017677486242985, is_adapt = false)])</code></pre><p>Now we pack the samples into an <code>MCMCChains.Chains</code>:</p><pre><code class="language-julia hljs">samples_transformed = reduce(vcat, fun.transform.(samples)&#39;)
varnames = Pathfinder.flattened_varnames_list(model)
chns = MCMCChains.Chains(samples_transformed, varnames)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (1000×3×1 Array{Float64, 3}):

Iterations        = 1:1:1000
Number of chains  = 1
Samples per chain = 1000
parameters        = α, β, σ

Summary Statistics
  parameters      mean       std   naive_se      mcse        ess      rhat
      Symbol   Float64   Float64    Float64   Float64    Float64   Float64

           α    1.4754    0.0420     0.0013    0.0018   538.1299    1.0012
           β    2.0060    0.0072     0.0002    0.0003   596.8061    1.0015
           σ    0.2163    0.0156     0.0005    0.0010   258.8120    1.0044

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
      Symbol   Float64   Float64   Float64   Float64   Float64

           α    1.3891    1.4474    1.4756    1.5034    1.5515
           β    1.9923    2.0013    2.0061    2.0109    2.0202
           σ    0.1887    0.2053    0.2154    0.2262    0.2489
</code></pre><p>See <a href="../initializing-hmc/#Initializing-HMC-with-Pathfinder">Initializing HMC with Pathfinder</a> for further examples.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../initializing-hmc/">« Initializing HMC</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Wednesday 4 May 2022 02:22">Wednesday 4 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
